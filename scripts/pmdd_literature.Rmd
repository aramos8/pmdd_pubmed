---
title: "Review of the current state of PMDD scientific literature in Pubmed"
output: html_notebook
---

# Introduction

*Write intro on PMDD and why it is important to learn more about it.*

# Data input

The data used in this analysis was all obtained from PubMed using the command line Entrez tools. The data was obtained in an XML file, which was then converted to JSON using [yq](https://github.com/mikefarah/yq), and then loaded onto a local database using DuckDB (`pmdd.db`). 

This notebook builds an in-memory database that allows for the analysis of the PMDD PubMed data using both SQL and R data frames as needed. 

# Analysis and visualization

This notebook will use  a combination of `DuckDB` and `tidyverse` packages to process the data. First, we will create an in-memory database that this notebook will be able to use to create tables to and extract data into data frames for downstream processing.

Once the database is created, we will install and load the DuckDB `json` package to enable parsing of the JSON file obtained from PubMed.

```{r}
library(duckdb)
library(tidyverse)

# Establish an in-memory database. This database will not persist outside of this notebook. 
con <- dbConnect(duckdb())
# or
#con <- dbConnect(duckdb(), dbdir = ":memory:")


# We first need to make sure our database has the required JSON packages
dbExecute(con, 
          "INSTALL json;
          LOAD json;")

```

Now that the database is created, let's load the data into the `entrez_clean` table using SQL.

```{r}
#Parse the JSON file and extract contents into a table in our database
dbExecute(con,
"
CREATE OR REPLACE TABLE entrez_clean AS 
WITH 
-- First, we load the JSON file in the unnest CTE
unnest AS (
        SELECT 
            UNNEST(Set.Publication, max_depth := 3)
        FROM read_json('pmdd_entrez.json')
    ),

--The JSON file obtained from ENTREZ results in inconsistent field formats. For the same column, there coulb be arrays and objects
--- To fix this, this CTE uses case statements to turn JSON OBJECTs into ARRAYs
even_nesting AS (
    SELECT 
        pubmed_id,
        pmc_id,
        doi,
        CASE WHEN JSON_TYPE(type) != 'ARRAY' THEN ARRAY_AGG(type) OVER (PARTITION BY pubmed_id) ELSE type END AS pub_type,
        sub_date,
        CAST(accepted_date AS DATE) AS accepted_date,
        pubdate,
        CASE WHEN JSON_TYPE(major_mesh_term) != 'ARRAY' THEN ARRAY_AGG(major_mesh_term) OVER (PARTITION BY pubmed_id) ELSE major_mesh_term END AS major_mesh,
        mesh_term AS mesh_terms,
        CASE WHEN JSON_TYPE(keyword) != 'ARRAY' THEN ARRAY_AGG(keyword) OVER (PARTITION BY pubmed_id) ELSE keyword END AS keywords,
        title,
        CASE WHEN JSON_TYPE(abstract) != 'ARRAY' THEN ARRAY_AGG(abstract) OVER (PARTITION BY pubmed_id) ELSE abstract END AS abstract,
        --CASE WHEN JSON_TYPE(author_full) != 'ARRAY' THEN ARRAY_AGG(author_full) OVER (PARTITION BY pubmed_id) ELSE author_full END AS authors,
        CASE WHEN JSON_TYPE(author) != 'ARRAY' THEN ARRAY_AGG(author) OVER (PARTITION BY pubmed_id) ELSE author END AS authors,
        CASE WHEN JSON_TYPE(author_id) != 'ARRAY' THEN ARRAY_AGG(author_id) OVER (PARTITION BY pubmed_id) ELSE author_id END AS author_ids,
        CASE WHEN JSON_TYPE(affiliation) != 'ARRAY' THEN ARRAY_AGG(affiliation) OVER (PARTITION BY pubmed_id) ELSE affiliation END AS author_affiliations,
        CASE WHEN JSON_TYPE(doi_reference) != 'ARRAY' THEN ARRAY_AGG(doi_reference) OVER (PARTITION BY pubmed_id) ELSE doi_reference END AS doi_references,
        pubmed_reference,
        pmc_reference
    FROM unnest
),

-- Once the data is loaded and uniform, we cast the remaining JSON fields as VARCHAR
casting AS (
    SELECT
        pubmed_id,    
        pmc_id,
        doi,
        CAST(pub_type AS VARCHAR[]) AS pub_type,
        sub_date,
        CAST(accepted_date AS DATE) AS accepted_date,
        pubdate,
        CAST(LEFT(pubdate,4) AS INT64) AS pub_year,
        CAST(major_mesh AS VARCHAR[]) AS major_mesh,
        CAST(mesh_terms AS VARCHAR[]) AS mesh_terms,
        CAST(keywords AS VARCHAR[]) AS keywords,
        title,
        CAST(abstract AS VARCHAR[]) AS abstract,
        CAST(authors AS VARCHAR[]) AS authors,
        CAST(author_ids AS VARCHAR[]) AS author_ids,
        CAST(author_affiliations AS VARCHAR[]) AS author_affiliations,
        CAST(doi_references AS VARCHAR[]) AS doi_references,
        CAST(pubmed_reference AS VARCHAR[]) AS pubmed_references,
        CAST(pmc_reference AS VARCHAR[]) AS pmc_references
    FROM even_nesting
),

-- With the data in good shape, we can now parse the authors details
authors_details_cte AS (
    SELECT DISTINCT
        pubmed_id,
        ARRAY_AGG(STRUCT_PACK(author_name, author_id, author_affiliation, author_index)) AS author_details,
    FROM (
        SELECT 
            * EXCLUDE(authors),
            ARRAY_POSITION(authors, author_name) AS author_index,
        FROM (
            SELECT 
                pubmed_id,
                authors,
                UNNEST(authors) AS author_name,
                UNNEST(author_affiliations) AS author_affiliation,
                UNNEST(author_ids) AS author_id
            FROM casting
            )
        )
        GROUP BY pubmed_id
)

SELECT 
    pubmed_id,
    pmc_id,
    doi,
    pub_type,
    sub_date,
    accepted_date,
    pubdate,
    CASE WHEN EXTRACT(YEAR FROM accepted_date) IS NULL THEN pub_year ELSE EXTRACT(YEAR FROM accepted_date) END AS publication_year,
    major_mesh,
    mesh_terms,
    keywords,
    title,
    abstract,
    author_details,
    pubmed_references,
    pmc_references,
    doi_references
FROM casting
LEFT JOIN authors_details_cte
USING(pubmed_id);
")

```

The SQL query above produces a table with a single record for each publication. Therefore, we can see that we have obtained information about 1334 PMDD pubications in total. 

As a precaution measure, let's create a data frame to show the current tables in our database to confirm that the table is present in our in-memory database. Since we have only created the `entrez_clean` table we should only see that table in the output. 

```{r}
# Let's now confirm that the table is in our database
db_tables <- dbGetQuery(con, 
"SHOW tables")
print(db_tables)
```
Now that the data is loaded we can start exploring it by further querying and building visualizations. Note that the table still has several nested fields, so let's continue using SQL to model the initial table into several subsequent tables to start getting some answers. To do so, let's first frame some of the questions we would like to answer in this notebook.

- How many PMDD articles were published in PubMed each year? 
- How many institutions have published PMDD articles?
- Which institution has been the most prolific in terms of PMDD publications?
- Who are the top 20 authors in the PMDD field (based on publication count)?
- What proportion of PMDD articles came from a Canadian institution? 
- How many keywords are used to describe PMDD articles on PubMed? 
  - What is the percentaje of articles that use keywords? 
  - Which are the top 50 keywords used in PMDD articles on PubMed? 
- How many MeSH terms are used to describe PMDD articles on PubMed? 
  - What is the percentaje of articles that use MeSH terms? 
  - Which are the top 50 MeSH terms used in PMDD articles on PubMed? 
  
Ok, now let's start exploring the data. Before we do that, lets load a couple of more libraries that we will need to build our models and visualizations:    
  
```{r}
library(tidyverse)
library("DBI")
```


```{r}

describe_table <- dbGetQuery(con,
"DESCRIBE entrez_clean")

```


## How many PMDD articles were published in PubMed each year? 

We will use the publication date, represented by the `pub_date` field in the `entrez_clean` table just added to our database. 

```{r}

articles_year <- dbGetQuery(con,
"SELECT 
  accepted_date,
  EXTRACT(YEAR FROM accepted_date) AS accepted_year,
  publication_year,
  pubmed_id,
FROM entrez_clean")

articles_year |>
  summarize(with_dates = n_distinct(case_when(is.na(accepted_date) == FALSE  ~ pubmed_id)),
            without_dates = n_distinct(case_when(is.na(accepted_date) ~ pubmed_id)),
            with_pubication_year = n_distinct(case_when(is.na(publication_year) == FALSE  ~ pubmed_id)),
            all = n_distinct(pubmed_id)
            )

```
Out of the 1,338 PMDD piblications in PubMed, only ~41% provide an accepted date (date when the publication was accepted by the publisher). For the publications missing this field, we can pull the "PubDate" field from Entrez, which corresponds to the date when the article became available in the journal. Therefore, we can create a new field, `publication_year`, which will use the year from the accepted_date, and the year from PubDate for the records where the accepted_date is not available. By doing so, we get 99% coverage.

First, let's keep in mind that out of the 1338 PMDD articles in PubMed, only ~41% of these articles have a value for their publication date. 

```{r}
#Let's get a list of the pubmed_ids that are missing a publication date. 
# no_date_articles <- articles_year |>
#   dplyr::filter(is.na(accepted_date)) |>
#   select(pubmed_id)

n_articles_year <- articles_year |>
  group_by(publication_year) |>
  summarize(articles = n_distinct(pubmed_id))
```

```{r}
ggplot(data = n_articles_year) +
  geom_col(mapping = aes(x = publication_year, y = articles))
```


## How many institutions have published PMDD articles?

All PMDD articles available in Pubmed have been published by 2412 institutions (there are 709 publications that do not show affiliation details). Of these, the 
```{r}
articles_institution <- dbGetQuery(con,
"SELECT 
    pubmed_id,
    author.author_details.author_name,
    author.author_details.author_affiliation
FROM entrez_clean, UNNEST(author_details) AS author")

n_institutions <- articles_institution %>%
  summarize(institutions = n_distinct(author_affiliation))
n_institutions
```


```{r}
n_articles_institution <- articles_institution %>%
  group_by(author_affiliation) %>% 
  summarize(articles = n_distinct(pubmed_id)) %>% 
  arrange(desc(articles)) %>% 
  top_n(20, articles)

n_articles_institution
```
## Who are the top 20 authors in the PMDD field (based on publication count)?

```{r}
n_articles_author <- articles_institution %>%
  group_by(author_name) %>% 
  summarize(articles = n_distinct(pubmed_id)) %>% 
  arrange(desc(articles)) %>% 
  top_n(20, articles)

n_articles_author
```



- What proportion of PMDD articles came from a Canadian institution? 
- How many keywords are used to describe PMDD articles on PubMed? 
  - What is the percentaje of articles that use keywords? 
  - Which are the top 50 keywords used in PMDD articles on PubMed? 
- How many MeSH terms are used to describe PMDD articles on PubMed? 
  - What is the percentaje of articles that use MeSH terms? 
  - Which are the top 50 MeSH terms used in PMDD articles on PubMed? 


Lastly, let's close the connection to the database:
```{r}
dbDisconnect(con, shutdown = TRUE)
```

